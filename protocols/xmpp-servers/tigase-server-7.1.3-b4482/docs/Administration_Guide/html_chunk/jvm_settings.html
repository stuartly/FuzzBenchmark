<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>JVM settings and recommendations</title><link rel="stylesheet" type="text/css" href="css/docbook-xsl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Tigase Administration Guide"><link rel="up" href="configuration.html" title="Chapter&nbsp;5.&nbsp;Configuration"><link rel="prev" href="confChanges5x.html" title="Configuration Storage Options in Tigase"><link rel="next" href="sessMan.html" title="Session Manager"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">JVM settings and recommendations</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="confChanges5x.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;5.&nbsp;Configuration</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="sessMan.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jvm_settings"></a>JVM settings and recommendations</h2></div></div></div><p>Tigase configuration file <code class="literal">tigase.conf</code> (described in more detail in <a class="xref" href="manualconfig.html" title="Startup File for tigase.sh - tigase.conf">the section called &#8220;Startup File for tigase.sh - tigase.conf&#8221;</a>) mentioned a couple of environmental variables which are related to the operation of the JVM. In this guide we would like to expound on those configuration options and provide hints for the optimal settings.</p><p>Settings included in the <code class="literal">etc/tigase.conf</code> are as follows:</p><pre class="programlisting">#GC="-XX:+UseBiasedLocking -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:NewRatio=2 -XX:+CMSIncrementalMode -XX:-ReduceInitialCardMarks -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSInitiatingOccupancyOnly"
#EX="-XX:+OptimizeStringConcat -XX:+DoEscapeAnalysis -XX:+UseNUMA"

#GC_DEBUG=" -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:logs/jvm.log -verbose:gc "

#PRODUCTION_HEAP_SETTINGS=" -Xms5G -Xmx5G " # heap memory settings must be adjusted on per deployment-base!
JAVA_OPTIONS="${GC} ${GC_DEBUG} ${EX} ${ENC} ${DRV} ${JMX_REMOTE_IP} -server ${PRODUCTION_HEAP_SETTINGS} ${DNS_RESOLVER} ${INTERNAL_IP} ${EXTERNAL_IP}  -XX:MaxDirectMemorySize=128m "</pre><p>And while this file utilizes bash variables, JVM configuration options can be used in the same manner on all operating systems.</p><p>The guide will consists of two main parts - memory settings and Garbage Collector tweaks descriptions and hints.</p><p>We recommend using <code class="literal">-server</code> JVM parameter in all cases.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_heap_sizing"></a>Heap Sizing</h3></div></div></div><p>For the non-production deployments (development or stating environments) we recommend using default memory settings of the JVM (which depends on the underlaying operating system), which result i automatic memory allocation and, by the rule of thumb - are the safest in such environments.</p><p>For the production environments we recommend a fixed size HEAP - both initial and maximum size, which can be set with (respectively)<code class="literal">-Xms</code> and <code class="literal">-Xmx</code> JVM flags - ideally to the same value (which should be roughtly 95% of the available memory, if Tigase will be the only service on the machine) to avoid allocation and deallocation.</p><p>For convenience it&#8217;s possible to uncomment line with <code class="literal">PRODUCTION_HEAP_SETTINGS</code> and adjust parameters accordingly.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_gc_settings"></a>GC settings</h3></div></div></div><p>Let&#8217;s start with stating that there is no "one to rule them all" - each deployment and use-case is different, however we will try to give a couple of pointers and recommendations proceed with short introduction to GC itself.</p><p>XMPP is quite specific in terms of memory allocation - short-lived objects (various types of stanzas) usually exceed number of long-lived objects (user connections and related data). This is important bit of information in the context of how usually JVM HEAP is organised and how Garbage Collector works. On the most basic level Heap is separated into couple of regions:</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_generations"></a>Generations</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara"><span class="strong"><strong>Young Generation</strong></span>, which is further divided in to:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><span class="strong"><strong>Eden</strong></span> - the region when the objects are usually allocated when they are created;</li><li class="listitem"><span class="strong"><strong>Survivor Spaces</strong></span> - (<span class="emphasis"><em>to</em></span> and <span class="emphasis"><em>from</em></span> - one of which is always empty) - responsible for storing all live object remaining after collecting <span class="strong"><strong>Young Generation</strong></span> (process is repeated several times until objects are finally considered <span class="emphasis"><em>old enough</em></span>);</li></ul></div></li><li class="listitem"><span class="strong"><strong>Old Generation</strong></span> - (<span class="emphasis"><em>Tenured Space</em></span>) - responsible for live objects remaining after running GC on <span class="strong"><strong>Survivor Spaces</strong></span> - those would be <span class="emphasis"><em>long-lived</em></span> objects (usually user connections and associated data);</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_minor_major_and_full_gc_optimizing"></a>Minor, Major and Full GC - optimizing</h4></div></div></div><p>General thinking suggests that:
* <span class="strong"><strong>Minor GC</strong></span> cleans Young generation;
* <span class="strong"><strong>Major GC</strong></span> cleans Tenured space;
* <span class="strong"><strong>Full GC</strong></span> cleans all heap.</p><p>However, while we can certainly state that Minor GC cleans Young generation it&#8217;s a bit more difficult to differentiate Major and Full GC, especially considering that Major GC can be quite often triggered by Minor GC and some garbage collectors can perform cleaning concurrently. Instead of focusing of distinguishing phases one should pay closer attention to actual operations of Garbage Collector itself - uncommenting the line <code class="literal">GC_DEBUG=" -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:logs/jvm.log -verbose:gc "</code> in <code class="literal">etc/tigase.conf</code> (or adding same properties to the java commandline) and subsequently analyzing the results should prove more helpful. In addition monitoring GC operation using for example VisualVM (with VisualGC plugin) will also be helpful.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_settings_for_xmpp"></a>Settings for XMPP</h4></div></div></div><p>Ideally we should limit both number of GC pauses as well as their duration. After running rather tests following conclusions were made:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Garbage Collection is the faster the more dead objects occupies given space, therefore on high-traffic installation it&#8217;s better to have rather large YoungGen resulting in lower promotion of the objects to the OldGen;</li><li class="listitem">with JVM8 default sizing of Young / Old generation changed, even tho NewRatio is still defaulting to &#8220;2&#8221; - setting it explicitly to "2" brought back previous sizing;</li><li class="listitem">Concurrent Mark and Sweep (CMS) enabled (applies to Tenured space only) with explicit configuration of NewRatio set to default value of 2 (i.e. <code class="literal">-XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:NewRatio=2</code>) in general behaves best;</li><li class="listitem">For small installations (few core CPU, less memory) with low traffic default Parallel collector may be a better solution;</li><li class="listitem">Using Heap size adjusted to the actual usage is better as the larger the heap the larger are spaces over which collection needs to be performed thus resulting in longer pauses; in case of huge heaps G1 collector may be better solution to avoid longer pauses;</li></ul></div><p>Considering all of the above using following options should be a good starting point toward further optimizing of Garbage Collection:</p><p><code class="literal">GC="-XX:+UseBiasedLocking -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSIncrementalMode -XX:-ReduceInitialCardMarks -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSInitiatingOccupancyOnly"</code></p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_gc_settings_worth_considering"></a>GC settings worth considering</h4></div></div></div><p>In addition to the general recommendation to use CMS collector, following options (or changes to the options) may be worth considering:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><code class="literal">-XX:NewRatio=2</code> - defines the ratio between the young and tenured generation is 1:2. In other words, the combined size of the eden and survivor spaces will be one-third of the total heap size. The parameters NewSize and MaxNewSize bound the young generation size from below and above. Setting these to the same value fixes the young generation, just as setting -Xms and -Xmx to the same value fixes the total heap size.</li><li class="listitem"><code class="literal">-XX:CMSInitiatingOccupancyFraction=percent</code> - sets the percentage of the old generation occupancy (0 to 100) at which to start a CMS collection cycle.</li><li class="listitem"><code class="literal">-XX:+UseCMSInitiatingOccupancyOnly</code> - instructs the JVM not to base its decision when to start a CMS cycle on run time statistics but instead it uses the value of CMSInitiatingOccupancyFraction for every CMS cycle.</li><li class="listitem"><code class="literal">-XX:ParallelGCThreads=x</code> - sets the number of threads used for parallel garbage collection in the young and old generations. The default value depends on the number of CPUs available to the JVM. If the Tigase JMV is the only one running on the installation default value is recommended.</li><li class="listitem"><code class="literal">-XX:ConcGCThreads=x</code> - sets the number of threads used for concurrent GC. The default value depends on the number of CPUs available to the JVM. If the Tigase JMV is the only one running on the installation default value is recommended.</li><li class="listitem"><code class="literal">-XX:+UseBiasedLocking</code> and <code class="literal">-XX:+DoEscapeAnalysis</code> - designed to eliminate locking overhead, however their effect on performance is unpredictable therefore testing is required; reduced locking should improve concurrency and, on current multi-core hardware, improve throughput.</li><li class="listitem"><code class="literal">-XX:+OptimizeStringConcat</code> - enables the optimization of String concatenation operations. This option is enabled by default.</li><li class="listitem"><code class="literal">-XX:+UseNUMA</code> - enables performance optimization of an application on a machine with nonuniform memory architecture (NUMA - most modern computers are based on NUMA architecture) by increasing the application&#8217;s use of lower latency memory. By default, this option is disabled and no optimization for NUMA is made. The option is only available when the parallel garbage collector is used (-XX:+UseParallelGC).</li><li class="listitem"><code class="literal">-XX:-UseCompressedOops</code>&#8201;&#8212;&#8201;disables the use of compressed pointers. By default, this option is enabled, and compressed pointers are used when Java heap sizes are less than 32 GB. When this option is enabled, object references are represented as 32-bit offsets instead of 64-bit pointers, which typically increases performance when running the application with Java heap sizes less than 32 GB. This option works only for 64-bit JVMs.</li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_what_to_use_with_machine_x_y_z"></a>What to use with Machine x, y, z?</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_server_class_machine_non_vm_16gb_8_core_cpu"></a>Server class machine (non-VM), &gt; 16GB, &gt;= 8 core CPU</h4></div></div></div><p>For such setup enabling CMS garbage collector is recommended. Depending on the traffic usage and particular use-case adjusting NewRatio may be needed. Adjusting Xms and Xms sizes for actual available memory is needed (or better yet, for the actual traffic!). Following should be used:</p><pre class="programlisting">GC="-XX:+UseBiasedLocking -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:NewRatio=2 -XX:+CMSIncrementalMode -XX:-ReduceInitialCardMarks -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSInitiatingOccupancyOnly"
EX="-XX:+OptimizeStringConcat -XX:+DoEscapeAnalysis -XX:+UseNUMA"

#GC_DEBUG=" -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:logs/jvm.log -verbose:gc "

PRODUCTION_HEAP_SETTINGS=" -Xms15G -Xmx15G " # heap memory settings must be adjusted on per deployment-base!
JAVA_OPTIONS="${GC} ${GC_DEBUG} ${EX} ${ENC} ${DRV} ${JMX_REMOTE_IP} -server ${PRODUCTION_HEAP_SETTINGS} ${DNS_RESOLVER} ${INTERNAL_IP} ${EXTERNAL_IP}  -XX:MaxDirectMemorySize=128m "</pre><p>For installation with lot of available memory and intention to utilize it all, using G1GC collector may be a better idea :</p><pre class="programlisting">GC="-XX:+UseG1GC -XX:ConcGCThreads=4 -XX:G1HeapRegionSize=2 -XX:InitiatingHeapOccupancyPercent=35 -XX:MaxGCPauseMillis=100"
EX="-XX:+OptimizeStringConcat -XX:+DoEscapeAnalysis -XX:+UseNUMA"

#GC_DEBUG=" -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:logs/jvm.log -verbose:gc "

PRODUCTION_HEAP_SETTINGS=" -Xms60G -Xmx60G " # heap memory settings must be adjusted on per deployment-base!
JAVA_OPTIONS="${GC} ${GC_DEBUG} ${EX} ${ENC} ${DRV} ${JMX_REMOTE_IP} -server ${PRODUCTION_HEAP_SETTINGS} ${DNS_RESOLVER} ${INTERNAL_IP} ${EXTERNAL_IP}  -XX:MaxDirectMemorySize=128m "</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_vm_machine_8gb_of_ram_4_core_cpu_equivalent"></a>VM machine, 8GB of RAM, 4 core CPU equivalent</h4></div></div></div><p>For such setup enabling CMS garbage collector is also recommended. Depending on the traffic usage and particular use-case adjusting NewRatio may be needed (and configuring NewRatio is a must!). Adjusting Xms and Xms sizes for actual available memory is needed (or better yet, for the actual traffic!). Following should be used:</p><pre class="programlisting">GC="-XX:+UseBiasedLocking -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:NewRatio=2 -XX:+CMSIncrementalMode -XX:-ReduceInitialCardMarks -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSInitiatingOccupancyOnly"
EX="-XX:+OptimizeStringConcat -XX:+DoEscapeAnalysis -XX:+UseNUMA"

#GC_DEBUG=" -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:logs/jvm.log -verbose:gc "

PRODUCTION_HEAP_SETTINGS=" -Xms7G -Xmx7G " # heap memory settings must be adjusted on per deployment-base!
JAVA_OPTIONS="${GC} ${GC_DEBUG} ${EX} ${ENC} ${DRV} ${JMX_REMOTE_IP} -server ${PRODUCTION_HEAP_SETTINGS} ${DNS_RESOLVER} ${INTERNAL_IP} ${EXTERNAL_IP}  -XX:MaxDirectMemorySize=128m "</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_vm_machine_with_4gb_or_less_of_ram_and_less_than_4_core_cpu_equivalent"></a>VM machine with 4GB or less of RAM, and less than 4 core CPU equivalent</h4></div></div></div><p>Small installations with limited resources could operate better with default (for JVM versions up to 8, which is the most current at the moment of the writing). Again - depending on the traffic usage and particular use-case adjusting NewRatio may be needed. Adjusting Xms and Xms sizes for actual available memory is recommended (or better yet, for the actual traffic!). Following should be used (i.e. <code class="literal">GC</code> line should be commented so the defaults will be used):</p><pre class="programlisting">#GC="-XX:+UseBiasedLocking -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:NewRatio=2 -XX:+CMSIncrementalMode -XX:-ReduceInitialCardMarks -XX:CMSInitiatingOccupancyFraction=70 -XX:+UseCMSInitiatingOccupancyOnly"
EX="-XX:+OptimizeStringConcat -XX:+DoEscapeAnalysis -XX:+UseNUMA"

#GC_DEBUG=" -XX:+PrintTenuringDistribution -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:logs/jvm.log -verbose:gc "

PRODUCTION_HEAP_SETTINGS=" -Xms3G -Xmx3G " # heap memory settings must be adjusted on per deployment-base!
JAVA_OPTIONS="${GC} ${GC_DEBUG} ${EX} ${ENC} ${DRV} ${JMX_REMOTE_IP} -server ${PRODUCTION_HEAP_SETTINGS} ${DNS_RESOLVER} ${INTERNAL_IP} ${EXTERNAL_IP}  -XX:MaxDirectMemorySize=128m "</pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_additional_resources"></a>Additional resources</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><a class="link" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html" target="_top">Sizing the Generations</a></li><li class="listitem"><a class="link" href="http://www.c0t0d0s0.org/archives/6617-About-Java,-parallel-garbage-collection-and-processor-sets.html" target="_top">About Java, parallel garbage collection and processor sets</a></li><li class="listitem"><a class="link" href="http://hiroshiyamauchi.blogspot.cl/2009/12/gc-threads.html" target="_top">GC Threads</a></li><li class="listitem"><a class="link" href="https://github.com/chewiebug/GCViewer#readme" target="_top">GCViewer readme</a></li><li class="listitem"><a class="link" href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html" target="_top">Java HotSpot&#8482; Virtual Machine Performance Enhancements</a></li><li class="listitem"><a class="link" href="https://plumbr.eu/java-garbage-collection-handbook" target="_top">Java Garbage Collection handbook</a></li><li class="listitem"><p class="simpara">Useful JVM Flags</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><a class="link" href="https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-1-jvm-types-and-compiler-modes/" target="_top">Part 1 - JVM Types and Compiler Modes</a></li><li class="listitem"><a class="link" href="https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-2-flag-categories-and-jit-compiler-diagnostics/" target="_top">Part 2 - Flag Categories and JIT Compiler Diagnostics)</a></li><li class="listitem"><a class="link" href="https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-3-printing-all-xx-flags-and-their-values/" target="_top">Part 3 - Printing all XX Flags and their Values</a></li><li class="listitem"><a class="link" href="https://blog.codecentric.de/en/2012/07/useful-jvm-flags-part-4-heap-tuning/" target="_top">Part 4 - Heap Tuning</a></li><li class="listitem"><a class="link" href="https://blog.codecentric.de/en/2012/08/useful-jvm-flags-part-5-young-generation-garbage-collection/" target="_top">Part 5 - Young Generation Garbage Collection</a></li><li class="listitem"><a class="link" href="https://blog.codecentric.de/en/2013/01/useful-jvm-flags-part-6-throughput-collector/" target="_top">Part 6 - Throughput Collector</a></li><li class="listitem"><a class="link" href="https://blog.codecentric.de/en/2013/10/useful-jvm-flags-part-7-cms-collector/" target="_top">Part 7 - CMS Collector</a></li><li class="listitem"><a class="link" href="https://blog.codecentric.de/en/2014/01/useful-jvm-flags-part-8-gc-logging/" target="_top">Part 8 - GC Logging</a></li></ul></div></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="confChanges5x.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="configuration.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="sessMan.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Configuration Storage Options in Tigase&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Session Manager</td></tr></table></div></body></html>