<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;10.&nbsp;Tigase DB Schema Explained</title><link rel="stylesheet" type="text/css" href="css/docbook-xsl.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="Tigase Development Guide"><link rel="up" href="index.html" title="Tigase Development Guide"><link rel="prev" href="oldStuff.html" title="Chapter&nbsp;9.&nbsp;Old Stuff"><link rel="next" href="whyRecentJDK.html" title="Chapter&nbsp;11.&nbsp;Why the most recent JDK?"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;10.&nbsp;Tigase DB Schema Explained</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="oldStuff.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="whyRecentJDK.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="tigaseDBSchema"></a>Chapter&nbsp;10.&nbsp;Tigase DB Schema Explained</h1></div></div></div><p>The schema basics, how it looks like and brief explanation to all rows can be found in the <a class="link" href="https://projects.tigase.org/projects/tigase-server/repository/revisions/master/entry/database/mysql-schema-4-schema.sql" target="_top">schema creation script</a>. However, this is hardly enough to understand how it works and how all the data is accessed. There are only 3 basic tables which actually keep all the Tigase server users' data: <span class="strong"><strong>tig_users</strong></span>, <span class="strong"><strong>tig_nodes</strong></span> and <span class="strong"><strong>tig_pairs</strong></span>. Therefore it is not clear at first how Tigase&#8217;s data is organized.</p><p>Before you can understand the Tigase XMPP Server database schema, how it works and how to use it, is it essential to know what were the goals of it&#8217;s development and why it works that way. Let&#8217;s start with the API as this gives you the best introduction.</p><p>Simplified access can be made through methods:</p><pre class="programlisting">void setData(BareJID user, String key, String value);
String getData(BareJID user, String key);</pre><p>And more a complex version:</p><pre class="programlisting">void setData(BareJID user, String subnode, String key, String value);
String getData(BareJID user, String subnode, String key, String def);</pre><p>Even though the API contains more methods, the rest is more or less a variation of presented above. A complete API description for all access methods is available in JavaDoc documentation in the <a class="link" href="https://projects.tigase.org/projects/tigase-server/repository/entry/trunk/src/main/java/tigase/db/UserRepository.java" target="_top">UserRepository</a> interface. So we are not going into too much detail here except for the main idea.</p><p>Tigase operates on &lt;*key*, <span class="strong"><strong>value</strong></span>&gt; pairs for the individual user data. The idea behind this was to make the API very simple and also at the same time very flexible, so adding a new plugin or component would not require a database schema change, adding new tables, or conversion of the DB schema to a new version.</p><p>As a result the <span class="strong"><strong>UserRepository</strong></span> interface is exposed to all of Tigase&#8217;s code, mainly the components and plugins (let&#8217;s call all of them modules). These modules simply call set/get methods to store or access module specific data.</p><p>As plugins or components are developed independently it may easily happen that developer choses the same key name to store some information. To avoid key name conflicts in the database a <span class="emphasis"><em>node</em></span> concept has been introduced. Therefore, most modules when set/get key value they also provide a subnode part, which in most cases is just XMLNS or some other unique string.</p><p>The <span class="emphasis"><em>node</em></span> thing is a little bit like directory in a file system, it may contain subnodes which makes the Tigase database behave like a hierarchical structure. And the notation is also similar to file systems, you use just <span class="strong"><strong>/</strong></span> to separate node levels. In practice you can have the database organized like this:</p><pre class="programlisting">user-name@domain  --&gt; (key, value) pairs
                   |
               roster --&gt;
                       |
                     item1 --&gt; (key1, value1) pairs.
                       |
                     item2 --&gt; (key1, value1) pairs.</pre><p>So to access item&#8217;s 1 data from the roster you could call method like this:</p><pre class="programlisting">getData("user-name@domain", "roster/item1", key1, def1);</pre><p>This is huge convenience for the developer, as he can focus on the module logic instead of worrying about data storage implementation and organization. Especially at the prototype phase it speeds development up and allows for a quick experiments with different solutions. In practice, accessing user&#8217;s roster in such a way would be highly inefficient so the roster is stored a bit differently but you get the idea. Also there is a more complex API used in some places allowing for more direct access to the database and store data in any format optimized for the scenario.</p><p>Right now such a hierarchical structure is implemented on top of SQL databases but initially Tigase&#8217;s database was implemented as an XML structure, so it was natural and simple.</p><p>In the SQL database we simulate hierarchical structure with three tables:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><span class="strong"><strong>tig_users</strong></span> - with main users data, user id (JID), optional password, active flag, creation time and some other basic properties of the account. All of them could be actually stored in tig_pairs but for performance reasons they are in one place to quickly access them with a single, simple query.</li><li class="listitem"><span class="strong"><strong>tig_nodes</strong></span> - is a table where the hierarchy is implemented. When Tigase was storing data in XML database the hierarchy was quite complex. However, in a SQL database it resulted in a very slow access to the data and a now more flat structure is used by most components. Please note, every user&#8217;s entry has something called root node, which is represented by <span class="emphasis"><em>root</em></span> string;</li><li class="listitem"><span class="strong"><strong>tig_pairs</strong></span> - this is the table where all the user&#8217;s information is stored in form of the &lt;key, value&gt; pairs.</li></ol></div><p>So we now know how the data is organized. Now we are going to learn how to access the data directly in the database using SQL queries.</p><p>Let&#8217;s assume we have a user <span class="emphasis"><em>admin@test-d</em></span> for whom we want to retrieve the roster. We could simply execute query:</p><pre class="programlisting">select pval
  from tig_users, tig_pairs
  where user_id = 'admin@test-d' and
        tig_users.uid = tig_pairs.uid and
        pkey = 'roster';</pre><p>However, if multiple modules store data under the key <span class="emphasis"><em>roster</em></span> for a single user, we would receive multiple results. To access the correct <span class="emphasis"><em>roster</em></span> we also have to know the node hierarchy for this particular key. The main users roster is stored under the <span class="emphasis"><em>root</em></span> node, so the query would look like:</p><pre class="programlisting">select pval
  from tig_users, tig_nodes, tig_pairs
  where user_id = 'admin@test-d' and
            tig_users.uid = tig_nodes.uid and
            node = 'root' and
            tig_users.uid = tig_pairs.uid and
           pkey = 'roster';</pre><p>How exactly the information is stored in the <span class="strong"><strong>tig_pairs</strong></span> table depends on the particular module. For the roster it looks a bit like XML content:</p><pre class="programlisting">&lt;contact jid="all-xmpp-test@test-d" subs="none" preped="simple" name="all-xmpp-test"/&gt;</pre></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="oldStuff.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="whyRecentJDK.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;9.&nbsp;Old Stuff&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;11.&nbsp;Why the most recent JDK?</td></tr></table></div></body></html>